---
date: 2018-11-7
tag: 
  - js
author: liuli
location: shanghai  
---
# 闭包

MDN 对闭包的定义为：

> 闭包是指那些能够访问自由变量的函数。

自由变量是什么呢？

> 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。

在实际使用中确认函数算是闭包呢？

1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
2. 代码中引用了自由变量

示例：

```
function foo() {
    var b = 30;

    function bar() {
        return b;
    }

    return bar;
}

var bar = foo();
bar(); // 30
```

简易分析下示例中 执行上下文栈和执行上下文的变化情况：

1. 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
2. 全局执行上下文初始化
3. 执行 foo 函数，创建 foo 函数执行上下文，foo 执行上下文压入执行上下文栈
4. foo 执行上下文初始化，创建变量对象，作用域链，this 等
5. foo 函数执行完毕，foo 函数执行上下文弹出执行上下文栈
6. 执行 bar 函数，创建 bar 函数执行上下文，bar 函数执行上下文压入执行上下文栈
7. bar 执行上下文初始化，创建变量对象，作用域链，this 等
8. bar 函数执行完毕，bar 函数执行上下文弹出执行上下文栈。

既然 foo 函数执行上下文已经在执行上下文栈中弹出了，那么为何 bar 函数还可以读取 foo 作用域下的 b 的值呢？

其实 bar 函数执行上下文中维护了一个作用域链：

```
EC(bar) = {
  [[scope chain]]: [AO(bar), fooContext.AO, globalContext.VO]
}
```

通过这个作用域链 bar 函数依然可以访问到 `fooContext.AO` 的值。也就是即使 fooContext 被销毁了，但 `fooContext.AO` 依然在 js 内存中保留，bar 函数依然可以通过其作用域链找到它。
